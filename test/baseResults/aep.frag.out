
Top IR:
; ModuleID = 'Glslang'

%inName = type { <4 x float> }

@color = global <4 x float> zeroinitializer
@inInst = global %inName zeroinitializer
@gl_Layer = global i32 0
@gl_PrimitiveID = global i32 0
@gl_SampleID = global i32 0
@gl_SamplePosition = global <2 x float> zeroinitializer
@gl_SampleMaskIn = global [1 x i32] zeroinitializer
@gl_SampleMask = global [1 x i32] zeroinitializer
@gl_NumSamples = external addrspace(2) constant i32

define fastcc void @main() {
entry:
  br label %mainBody

mainBody:                                         ; preds = %entry
  %color = load <4 x float>* getelementptr inbounds (%inName* @inInst, i32 0, i32 0)
  store <4 x float> %color, <4 x float>* @color
  %0 = call i32 @"foo_GS("()
  %1 = sitofp i32 %0 to float, !gla.precision !23
  %2 = load <4 x float>* @color
  %3 = insertelement <4 x float> undef, float %1, i32 0, !gla.precision !23
  %4 = insertelement <4 x float> %3, float %1, i32 1, !gla.precision !23
  %5 = insertelement <4 x float> %4, float %1, i32 2, !gla.precision !23
  %6 = insertelement <4 x float> %5, float %1, i32 3, !gla.precision !23
  %color1 = fmul <4 x float> %2, %6, !gla.precision !23
  store <4 x float> %color1, <4 x float>* @color
  call void @"goodSample("()
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %mainBody
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: alwaysinline
define internal fastcc i32 @"foo_GS("() #0 {
entry:
  %p = alloca i32
  %l = alloca i32
  %l1 = load i32* @gl_Layer
  store i32 %l1, i32* %l
  %p2 = load i32* @gl_PrimitiveID
  store i32 %p2, i32* %p
  %0 = load i32* %l
  %1 = load i32* %p
  %2 = add i32 %0, %1, !gla.precision !23
  ret i32 %2

post-return:                                      ; No predecessors!
  unreachable
}

; Function Attrs: alwaysinline
define internal fastcc void @"goodSample("() #0 {
entry:
  %n2 = alloca i32
  %n1 = alloca i32
  %a3 = alloca i32
  %a2 = alloca <2 x float>
  %a1 = alloca i32
  %a11 = load i32* @gl_SampleID
  store i32 %a11, i32* %a1
  %a22 = load <2 x float>* @gl_SamplePosition
  store <2 x float> %a22, <2 x float>* %a2
  %a33 = load i32* getelementptr inbounds ([1 x i32]* @gl_SampleMaskIn, i32 0, i32 0)
  store i32 %a33, i32* %a3
  %0 = load i32* %a3
  store i32 %0, i32* getelementptr inbounds ([1 x i32]* @gl_SampleMask, i32 0, i32 0)
  store i32 4, i32* %n1
  %n24 = load i32 addrspace(2)* @gl_NumSamples, !gla.uniform !21
  store i32 %n24, i32* %n2
  %1 = load i32* %n1
  %2 = load i32* %n2
  %3 = add i32 %1, %2, !gla.precision !24
  %4 = load i32* %a1
  %5 = add i32 %3, %4, !gla.precision !24
  %6 = load i32* getelementptr inbounds ([1 x i32]* @gl_SampleMask, i32 0, i32 0)
  %7 = add i32 %6, %5, !gla.precision !23
  store i32 %7, i32* getelementptr inbounds ([1 x i32]* @gl_SampleMask, i32 0, i32 0)
  %8 = load <2 x float>* %a2
  %9 = load <4 x float>* @color
  %10 = extractelement <4 x float> %9, i32 0, !gla.precision !23
  %11 = insertelement <2 x float> undef, float %10, i32 0, !gla.precision !23
  %12 = extractelement <4 x float> %9, i32 1, !gla.precision !23
  %13 = insertelement <2 x float> %11, float %12, i32 1, !gla.precision !23
  %14 = fadd <2 x float> %13, %8, !gla.precision !23
  %15 = load <4 x float>* @color
  %16 = extractelement <2 x float> %14, i32 0
  %17 = insertelement <4 x float> %15, float %16, i32 0
  %18 = extractelement <2 x float> %14, i32 1
  %color = insertelement <4 x float> %17, float %18, i32 1
  store <4 x float> %color, <4 x float>* @color
  ret void
}

attributes #0 = { alwaysinline }

!gla.entrypoint = !{!0}
!gla.outputs = !{!1, !3}
!gla.inputs = !{!5, !11, !13, !15, !17, !19}
!gla.uniforms = !{!21}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"color", i32 7, <4 x float>* @color_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 3, i32 1024, null, i32 0}
!3 = metadata !{metadata !"gl_SampleMask", i32 7, [1 x i32]* @gl_SampleMask_typeProxy, metadata !4}
!4 = metadata !{i32 0, i32 3, i32 1031, null, i32 0, i32 48}
!5 = metadata !{metadata !"inInst", i32 17, %inName* @inInst_typeProxy, metadata !6, metadata !7}
!6 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}
!7 = metadata !{metadata !"inName", metadata !8, metadata !"color", metadata !9}
!8 = metadata !{i32 0, i32 0, i32 1024, null}
!9 = metadata !{metadata !"", metadata !10}
!10 = metadata !{i32 0, i32 3, i32 1024, null}
!11 = metadata !{metadata !"gl_Layer", i32 1, i32* @gl_Layer_typeProxy, metadata !12}
!12 = metadata !{i32 0, i32 3, i32 1026, null, i32 0, i32 32}
!13 = metadata !{metadata !"gl_PrimitiveID", i32 1, i32* @gl_PrimitiveID_typeProxy, metadata !14}
!14 = metadata !{i32 0, i32 3, i32 1027, null, i32 0, i32 31}
!15 = metadata !{metadata !"gl_SampleID", i32 1, i32* @gl_SampleID_typeProxy, metadata !16}
!16 = metadata !{i32 0, i32 1, i32 1028, null, i32 0, i32 46}
!17 = metadata !{metadata !"gl_SamplePosition", i32 1, <2 x float>* @gl_SamplePosition_typeProxy, metadata !18}
!18 = metadata !{i32 0, i32 2, i32 1029, null, i32 1, i32 47}
!19 = metadata !{metadata !"gl_SampleMaskIn", i32 1, [1 x i32]* @gl_SampleMaskIn_typeProxy, metadata !20}
!20 = metadata !{i32 0, i32 3, i32 1030, null, i32 0, i32 48}
!21 = metadata !{metadata !"gl_NumSamples", i32 12, i32* @gl_NumSamples_typeProxy, metadata !22}
!22 = metadata !{i32 0, i32 1, i32 1024, null}
!23 = metadata !{i32 3}
!24 = metadata !{i32 2}


Bottom IR:
; ModuleID = 'Glslang'

%inName = type { <4 x float> }

@color = global <4 x float> zeroinitializer
@inInst = global %inName zeroinitializer
@gl_Layer = global i32 0
@gl_PrimitiveID = global i32 0
@gl_SampleID = global i32 0
@gl_SamplePosition = global <2 x float> zeroinitializer
@gl_SampleMaskIn = global [1 x i32] zeroinitializer
@gl_SampleMask = global [1 x i32] zeroinitializer
@gl_NumSamples = external addrspace(2) constant i32

define fastcc void @main() {
entry:
  %gla_constGEP = getelementptr %inName* @inInst, i32 0, i32 0
  %color = load <4 x float>* %gla_constGEP, align 16
  store <4 x float> %color, <4 x float>* @color, align 16
  %l1.i = load i32* @gl_Layer, align 4
  %p2.i = load i32* @gl_PrimitiveID, align 4
  %0 = add i32 %p2.i, %l1.i, !gla.precision !23
  %1 = sitofp i32 %0 to float, !gla.precision !23
  %2 = call <4 x float> @llvm.gla.fSwizzle.v4f32.f32.v4i32(float %1, <4 x i32> zeroinitializer)
  %color1 = fmul <4 x float> %color, %2, !gla.precision !23
  %3 = call <2 x float> @llvm.gla.fSwizzle.v2f32.v4f32.v2i32(<4 x float> %color1, <2 x i32> <i32 0, i32 1>)
  store <4 x float> %color1, <4 x float>* @color, align 16
  %a11.i = load i32* @gl_SampleID, align 4
  %a22.i = load <2 x float>* @gl_SamplePosition, align 8
  %gla_constGEP2 = getelementptr [1 x i32]* @gl_SampleMaskIn, i32 0, i32 0
  %a33.i = load i32* %gla_constGEP2, align 4
  %gla_constGEP3 = getelementptr [1 x i32]* @gl_SampleMask, i32 0, i32 0
  store i32 %a33.i, i32* %gla_constGEP3, align 4
  %n24.i = load i32 addrspace(2)* @gl_NumSamples, align 4, !gla.uniform !21
  %4 = add i32 %a11.i, 4, !gla.precision !24
  %5 = add i32 %4, %a33.i, !gla.precision !24
  %6 = add i32 %5, %n24.i, !gla.precision !23
  %gla_constGEP4 = getelementptr [1 x i32]* @gl_SampleMask, i32 0, i32 0
  store i32 %6, i32* %gla_constGEP4, align 4
  %7 = fadd <2 x float> %a22.i, %3, !gla.precision !23
  %8 = call <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.v2f32.v2f32.f32.f32(<4 x float> %color1, i32 3, <2 x float> %7, i32 0, <2 x float> %7, i32 1, float undef, i32 undef, float undef, i32 undef)
  store <4 x float> %8, <4 x float>* @color, align 16
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.v2f32.v2f32.f32.f32(<4 x float>, i32, <2 x float>, i32, <2 x float>, i32, float, i32, float, i32) #0

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fSwizzle.v4f32.f32.v4i32(float, <4 x i32>) #0

; Function Attrs: nounwind readnone
declare <2 x float> @llvm.gla.fSwizzle.v2f32.v4f32.v2i32(<4 x float>, <2 x i32>) #0

attributes #0 = { nounwind readnone }

!gla.entrypoint = !{!0}
!gla.outputs = !{!1, !3}
!gla.inputs = !{!5, !11, !13, !15, !17, !19}
!gla.uniforms = !{!21}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"color", i32 7, <4 x float>* @color_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 3, i32 1024, null, i32 0}
!3 = metadata !{metadata !"gl_SampleMask", i32 7, [1 x i32]* @gl_SampleMask_typeProxy, metadata !4}
!4 = metadata !{i32 0, i32 3, i32 1031, null, i32 0, i32 48}
!5 = metadata !{metadata !"inInst", i32 17, %inName* @inInst_typeProxy, metadata !6, metadata !7}
!6 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}
!7 = metadata !{metadata !"inName", metadata !8, metadata !"color", metadata !9}
!8 = metadata !{i32 0, i32 0, i32 1024, null}
!9 = metadata !{metadata !"", metadata !10}
!10 = metadata !{i32 0, i32 3, i32 1024, null}
!11 = metadata !{metadata !"gl_Layer", i32 1, i32* @gl_Layer_typeProxy, metadata !12}
!12 = metadata !{i32 0, i32 3, i32 1026, null, i32 0, i32 32}
!13 = metadata !{metadata !"gl_PrimitiveID", i32 1, i32* @gl_PrimitiveID_typeProxy, metadata !14}
!14 = metadata !{i32 0, i32 3, i32 1027, null, i32 0, i32 31}
!15 = metadata !{metadata !"gl_SampleID", i32 1, i32* @gl_SampleID_typeProxy, metadata !16}
!16 = metadata !{i32 0, i32 1, i32 1028, null, i32 0, i32 46}
!17 = metadata !{metadata !"gl_SamplePosition", i32 1, <2 x float>* @gl_SamplePosition_typeProxy, metadata !18}
!18 = metadata !{i32 0, i32 2, i32 1029, null, i32 1, i32 47}
!19 = metadata !{metadata !"gl_SampleMaskIn", i32 1, [1 x i32]* @gl_SampleMaskIn_typeProxy, metadata !20}
!20 = metadata !{i32 0, i32 3, i32 1030, null, i32 0, i32 48}
!21 = metadata !{metadata !"gl_NumSamples", i32 12, i32* @gl_NumSamples_typeProxy, metadata !22}
!22 = metadata !{i32 0, i32 1, i32 1024, null}
!23 = metadata !{i32 3}
!24 = metadata !{i32 2}
#version 310 es
// LunarGOO output
#extension GL_ANDROID_extension_pack_es31a : enable
#extension GL_EXT_geometry_shader : enable
#extension GL_EXT_gpu_shader5 : enable
#extension GL_EXT_primitive_bounding_box : enable
#extension GL_EXT_shader_io_blocks : enable
#extension GL_EXT_tessellation_shader : enable
#extension GL_EXT_texture_buffer : enable
#extension GL_EXT_texture_cube_map_array : enable
#extension GL_KHR_blend_equation_advanced : enable
#extension GL_OES_sample_variables : enable
#extension GL_OES_shader_image_atomic : enable
#extension GL_OES_shader_multisample_interpolation : enable
#extension GL_OES_texture_storage_multisample_2d_array : enable
precision mediump float; // this will be almost entirely overridden by individual declarations
in inName {
	highp vec4 color;
} inInst;
out highp vec4 color;
const int C_4 = 4;

void main()
{
	color = inInst.color;
	highp int H_788oq2 = gl_Layer + gl_PrimitiveID;
	highp float H_ycwbmg1 = float(H_788oq2);
	vec4 H_jsty0g = vec4(H_ycwbmg1);
	highp vec4 color1 = H_jsty0g * inInst.color;
	color = color1;
	gl_SampleMask[0] = gl_SampleMaskIn[0];
	mediump int H_fijw1n1 = gl_SampleID + C_4;
	mediump int H_m4wmqm1 = H_fijw1n1 + gl_SampleMaskIn[0];
	highp int H_89h7ub = H_m4wmqm1 + gl_NumSamples;
	gl_SampleMask[0] = H_89h7ub;
	highp vec2 H_kbfl6m1 = color1.xy + gl_SamplePosition;
	vec4 H_np3y8f = color1;
	H_np3y8f.xy = H_kbfl6m1.xy;
	color = H_np3y8f;
	
}

#version 310 es
// LunarGOO output
#extension GL_ANDROID_extension_pack_es31a : enable
#extension GL_EXT_geometry_shader : enable
#extension GL_EXT_gpu_shader5 : enable
#extension GL_EXT_primitive_bounding_box : enable
#extension GL_EXT_shader_io_blocks : enable
#extension GL_EXT_tessellation_shader : enable
#extension GL_EXT_texture_buffer : enable
#extension GL_EXT_texture_cube_map_array : enable
#extension GL_KHR_blend_equation_advanced : enable
#extension GL_OES_sample_variables : enable
#extension GL_OES_shader_image_atomic : enable
#extension GL_OES_shader_multisample_interpolation : enable
#extension GL_OES_texture_storage_multisample_2d_array : enable
precision mediump float; // this will be almost entirely overridden by individual declarations
in inName {
	highp vec4 color;
} inInst;
out highp vec4 color;
const int C_4 = 4;

void main()
{
	color = inInst.color;
	highp int H_788oq = gl_Layer + gl_PrimitiveID;
	highp float H_ycwbmg = float(H_788oq);
	vec4 H_0w2kui1 = vec4(H_ycwbmg);
	highp vec4 color1 = H_0w2kui1 * inInst.color;
	color = color1;
	gl_SampleMask[0] = gl_SampleMaskIn[0];
	mediump int H_fijw1n = gl_SampleID + C_4;
	highp int H_m4wmqm = H_fijw1n + gl_SampleMaskIn[0];
	mediump int H_89h7ub = H_m4wmqm + gl_NumSamples;
	gl_SampleMask[0] = H_89h7ub;
	highp vec2 H_kbfl6m = color1.xy + gl_SamplePosition;
	vec4 H_np3y8f = color1;
	H_np3y8f.xy = H_kbfl6m.xy;
	color = H_np3y8f;
	
}

